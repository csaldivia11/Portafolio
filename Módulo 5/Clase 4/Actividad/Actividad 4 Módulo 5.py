# -*- coding: utf-8 -*-
"""Actividad 4 Módulo 5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-1NJQJRbAUtpY9hECCUhaX1XGf-f_4ym
"""

import pandas as pd
import re
#GRUPO 4
# 1. Cargar el archivo con pd.read_csv()
df = pd.read_csv('clientes_eval_formativa_m5_s4.csv')
# 2. Calcular el porcentaje de completitud
completitud = df.notnull().mean() * 100
# 3. Validar campos con una expresión regular y calcular el porcentaje de validez
def es_correo_valido(email):
    # Asegurarse de que el email es un string antes de usar regex
    if not isinstance(email, str):
        return False
    # Expresión regular para validar un correo electrónico
    regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return re.match(regex, email) is not None
def es_telefono_valido(telefono):
    """Valida si un número de teléfono tiene 9 dígitos y empieza con '9'."""
    # Se convierte a string para manejar datos que puedan ser numéricos
    telefono_str = str(telefono)
    if pd.isna(telefono) or telefono is None:
        return False
    # Un teléfono válido debe ser un string de 9 dígitos y empezar con '9'
    if telefono_str.isdigit() and len(telefono_str) == 9 and telefono_str.startswith('9'):
        return True
    return False

# Se asume 100% de validez para 'id_cliente' y 'nombre' según el contexto del ejercicio.
# La validez del email se calcula en base a la función.
validez = {
    'id_cliente': 100.0,
    'nombre': df['nombre'].notnull().mean() * 100, # Consideramos valido que no este en blanco
    'email': df['email'].apply(es_correo_valido).mean() * 100,
    'telefono': df['telefono'].apply(es_telefono_valido).mean() * 100,
    'origen_dato': df['origen_dato'].notnull().mean() * 100, # Consideramos valido que no este en blanco
    'fecha_actualizacion': df['fecha_actualizacion'].notnull().mean() * 100 # Consideramos valido que no este en blanco
}
validez_series = pd.Series(validez)

# 4. Detectar duplicados
duplicados = {
    'id_cliente': df['id_cliente'].duplicated().sum(),
    'nombre': df['nombre'].duplicated().sum(),
    'email': df['email'].duplicated().sum()
}
duplicados_series = pd.Series(duplicados)

# 5. Construir la tabla de diagnóstico
tabla_diagnostico = pd.DataFrame({
    'Completitud (%)': completitud,
    'Validez (%)': validez_series,
    'Duplicados': duplicados_series
    #'Precisión':
})

print("--- Diagnóstico de Calidad de Datos ---")
print(tabla_diagnostico.round(2))
print("\n--- Análisis de Hallazgos ---")

# Identificar el campo con más errores
campo_mas_errores = tabla_diagnostico[['Completitud (%)', 'Validez (%)']].min(axis=1).idxmin()
print(f"1. Campo con más problemas: '{campo_mas_errores}'")

# Identificar la dimensión de calidad más comprometida
dimension_mas_comprometida = tabla_diagnostico[['Completitud (%)', 'Validez (%)']].min().idxmin()
print(f"2. Dimensión más comprometida: {dimension_mas_comprometida}")

# Consecuencias en el negocio
print("3. Posibles consecuencias en el negocio:")
print("- Campañas de marketing fallidas y recursos desperdiciados si los emails no son válidos.")
print("- Problemas de comunicación y fidelización al no poder contactar a los clientes.")
print("- Análisis de clientes sesgado que puede llevar a tomar malas decisiones estratégicas.")